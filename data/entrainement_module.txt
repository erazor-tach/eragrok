# data/entrainement_module.py
# Écran d'entraînement intégré avec data/training_techniques.py
# - Utilise les techniques classées pour remplir les listes Myofi / Sarco
# - Affiche description complète des techniques dans la listbox
# - Met à jour combobox quand on change de programme
# - Permet double-clic pour voir le détail d'une technique

import os
import csv
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox
from tkcalendar import Calendar
from data import utils
from data import training_techniques as tt

def _ensure_user_dir(app):
    user_dir = os.path.join(utils.USERS_DIR, app.current_user)
    Path(user_dir).mkdir(parents=True, exist_ok=True)
    return user_dir

def _technique_options_for_program(program_name=None):
    """
    Retourne deux listes (myofi_options, sarco_options) pour remplir les combobox.
    Les listes contiennent des libellés 'Nom — reps — charge' pour lisibilité.
    """
    myofi_list = tt.get_techniques_for_program("Myofi")
    sarco_list = tt.get_techniques_for_program("Sarco")
    myofi_opts = [f"{t['nom']} — {t['reps']} — {t['charge']} ({t['id']})" for t in myofi_list]
    sarco_opts = [f"{t['nom']} — {t['reps']} — {t['charge']} ({t['id']})" for t in sarco_list]
    return myofi_opts, sarco_opts

def show_entrainement_screen(app, program=None):
    # clear content
    for w in app.content.winfo_children():
        w.destroy()

    tk.Label(app.content, text=f"ENTRAÎNEMENT - Élève : {getattr(app, 'selected_user_name', '—')}", font=("Helvetica", 20, "bold"), bg="#f3f4f6", fg="#0f172a").pack(pady=12)

    top = tk.Frame(app.content, bg="#f3f4f6")
    top.pack(fill='x', padx=20)
    tk.Label(top, text="Programme :", bg="#f3f4f6").pack(side='left')
    app.program_selected_var = tk.StringVar(value=program if program else "Standard")
    prog_combo = ttk.Combobox(top, values=["Standard", "Sarco", "Myofi"], textvariable=app.program_selected_var, state="readonly", width=18)
    prog_combo.pack(side='left', padx=8)
    # when program changes, refresh combos and list
    prog_combo.bind("<<ComboboxSelected>>", lambda ev: _on_program_change(app))
    ttk.Button(top, text="Charger", command=lambda: _load_program(app, app.program_selected_var.get())).pack(side='left', padx=6)
    ttk.Button(top, text="Retour Dashboard", command=getattr(app, "show_dashboard", lambda: None)).pack(side='right')

    cal_frame = tk.Frame(app.content, bg="#f3f4f6")
    cal_frame.pack(pady=8, fill='x', padx=20)
    app.calendar = Calendar(cal_frame, selectmode='day')
    app.calendar.pack(side='left', padx=12)

    # groupes musculaires
    groupes_frame = tk.Frame(app.content, bg="#f3f4f6")
    groupes_frame.pack(anchor='w', padx=40, pady=(10,6))
    tk.Label(groupes_frame, text="Groupes musculaires :", font=("Helvetica", 12, "bold"), bg="#f3f4f6").pack(anchor='w')
    app.groupes_vars = {}
    groupes = ["Pecs", "Dos", "Cuisses", "Épaules", "Bras", "Full body", "Alpha body"]
    chk_frame = tk.Frame(groupes_frame, bg="#f3f4f6")
    chk_frame.pack(anchor='w', pady=6)
    for i, g in enumerate(groupes):
        var = tk.BooleanVar()
        cb = tk.Checkbutton(chk_frame, text=g, variable=var, bg="#f3f4f6", anchor='w')
        cb.grid(row=i//2, column=i%2, sticky='w', padx=8, pady=4)
        app.groupes_vars[g] = var

    # types (remplis dynamiquement depuis training_techniques)
    type_frame = tk.Frame(app.content, bg="#f3f4f6")
    type_frame.pack(fill='x', padx=40, pady=(10,6))
    left_tf = tk.Frame(type_frame, bg="#f3f4f6"); left_tf.pack(side='left', padx=8, anchor='n')
    tk.Label(left_tf, text="Myofibrillaire (force)", font=("Helvetica", 12, "bold"), bg="#f3f4f6").pack(anchor='w')
    app.myofib_var = tk.StringVar()
    myofi_opts, sarco_opts = _technique_options_for_program(None)
    app._myo_combo = ttk.Combobox(left_tf, values=myofi_opts, textvariable=app.myofib_var, state="readonly", width=60)
    app._myo_combo.pack(pady=6)
    right_tf = tk.Frame(type_frame, bg="#f3f4f6"); right_tf.pack(side='left', padx=8, anchor='n')
    tk.Label(right_tf, text="Sarcoplasmique (volume)", font=("Helvetica", 12, "bold"), bg="#f3f4f6").pack(anchor='w')
    app.sarco_var = tk.StringVar()
    app._sarco_combo = ttk.Combobox(right_tf, values=sarco_opts, textvariable=app.sarco_var, state="readonly", width=60)
    app._sarco_combo.pack(pady=6)

    # program listbox (affiche séances / techniques avec description)
    program_frame = tk.Frame(app.content, bg="#ffffff", bd=0)
    program_frame.pack(fill='both', expand=True, padx=20, pady=12)
    program_frame.configure(padx=12, pady=12)
    tk.Label(program_frame, text="Détails du programme / Techniques", font=("Helvetica", 12, "bold"), bg="#ffffff").pack(anchor='w')
    app.program_listbox = tk.Listbox(program_frame, height=12, width=120)
    app.program_listbox.pack(pady=8, fill='both', expand=True)
    # double click to open technique detail
    app.program_listbox.bind("<Double-1>", lambda ev: _on_listbox_double_click(app))

    # action buttons
    action_frame = tk.Frame(program_frame, bg="#ffffff")
    action_frame.pack(anchor='w', pady=(6,0))
    ttk.Button(action_frame, text="Voir détail sélection", command=lambda: _on_listbox_double_click(app)).pack(side='left', padx=6)
    ttk.Button(action_frame, text="Charger techniques du programme", command=lambda: _load_program(app, app.program_selected_var.get())).pack(side='left', padx=6)

    app.note_text = tk.Text(app.content, height=6, width=100)
    app.note_text.pack(padx=20, pady=8)
    btn_frame = tk.Frame(app.content, bg="#f3f4f6")
    btn_frame.pack(pady=8)
    ttk.Button(btn_frame, text="SAUVEGARDER ENTRAÎNEMENT", command=lambda: _sauvegarder_entrainement(app)).pack(side='left', padx=6)
    ttk.Button(btn_frame, text="Retour Dashboard", command=getattr(app, "show_dashboard", lambda: None)).pack(side='left', padx=6)

    # initial load
    _refresh_combos(app)
    _load_program(app, app.program_selected_var.get())

def _on_program_change(app):
    # update combobox options when program selection changes
    _refresh_combos(app)
    # optionally auto-load the program template
    _load_program(app, app.program_selected_var.get())

def _refresh_combos(app):
    myo_opts, sarco_opts = _technique_options_for_program(None)
    try:
        app._myo_combo.config(values=myo_opts)
        app._sarco_combo.config(values=sarco_opts)
    except Exception:
        pass

def _load_program(app, name):
    """
    Charge un template de programme :
      - Si Myofi ou Sarco : utilise training_techniques.build_program_template
      - Sinon : charge un programme Standard simple
    Affiche les séances et, pour chaque exercice, sa description (nom, reps, charge, objectif, notes).
    """
    app.program_listbox.delete(0, tk.END)
    if name == "Sarco":
        template = tt.build_program_template("Sarco", weeks=4)
        for w in template["weeks"]:
            for s in w["sessions"]:
                for ex in s["exercises"]:
                    # find full technique info if exists
                    tech = tt.find_technique_by_id(ex.get("id")) or {}
                    desc = _format_tech_line(ex, tech, w['week'], s['session'])
                    app.program_listbox.insert(tk.END, desc)
    elif name == "Myofi":
        template = tt.build_program_template("Myofi", weeks=4)
        for w in template["weeks"]:
            for s in w["sessions"]:
                for ex in s["exercises"]:
                    tech = tt.find_technique_by_id(ex.get("id")) or {}
                    desc = _format_tech_line(ex, tech, w['week'], s['session'])
                    app.program_listbox.insert(tk.END, desc)
    else:
        # Standard: show a simple default program
        exercises = [
            {"nom": "Pecs/Dos 4x8-10", "reps": "4x8-10", "charge": "modérée", "notes": "Standard"},
            {"nom": "Jambes 4x8-10", "reps": "4x8-10", "charge": "modérée", "notes": "Standard"},
            {"nom": "Épaules/Arms 4x8-10", "reps": "4x8-10", "charge": "modérée", "notes": "Standard"}
        ]
        for i, ex in enumerate(exercises, start=1):
            line = f"Jour {i} — {ex['nom']} — {ex['reps']} — {ex['charge']} — {ex['notes']}"
            app.program_listbox.insert(tk.END, line)

def _format_tech_line(ex, tech, week=None, session=None):
    """
    Retourne une ligne lisible pour la listbox contenant :
    Semaine X - Séance Y - Nom [reps] | Charge | Objectif | Notes (id)
    """
    nom = ex.get("nom") or tech.get("nom", "—")
    reps = ex.get("reps") or tech.get("reps", "—")
    charge = ex.get("charge") or tech.get("charge", "—")
    objectif = tech.get("objectif", "")
    notes = tech.get("notes", "")
    tid = tech.get("id", ex.get("id", ""))
    prefix = ""
    if week is not None and session is not None:
        prefix = f"S{week}‑S{session} — "
    return f"{prefix}{nom} [{reps}] | {charge} | {objectif} | {notes} ({tid})"

def _on_listbox_double_click(app):
    sel = app.program_listbox.curselection()
    if not sel:
        messagebox.showinfo("Détail", "Sélectionne une ligne d'abord.")
        return
    idx = sel[0]
    line = app.program_listbox.get(idx)
    # try to extract id between parentheses at end
    tid = None
    if "(" in line and ")" in line:
        tid = line.split("(")[-1].split(")")[0].strip()
    # if tid found and exists in techniques, show full detail
    tech = tt.find_technique_by_id(tid) if tid else None
    if tech:
        _open_tech_detail_dialog(app, tech)
    else:
        # fallback: show the raw line in a dialog
        dlg = tk.Toplevel()
        dlg.title("Détail")
        dlg.transient(app.root if hasattr(app, "root") else app.content)
        tk.Label(dlg, text=line, wraplength=600, justify='left').pack(padx=12, pady=12)
        ttk.Button(dlg, text="Fermer", command=dlg.destroy).pack(pady=(0,12))

def _open_tech_detail_dialog(app, tech):
    dlg = tk.Toplevel()
    dlg.title(f"Détail : {tech.get('nom')}")
    dlg.transient(app.root if hasattr(app, "root") else app.content)
    dlg.grab_set()
    frame = tk.Frame(dlg)
    frame.pack(padx=12, pady=12)
    tk.Label(frame, text=f"Nom : {tech.get('nom')}", font=("Helvetica", 12, "bold")).grid(row=0, column=0, sticky='w')
    tk.Label(frame, text=f"ID : {tech.get('id')}").grid(row=1, column=0, sticky='w', pady=(4,0))
    tk.Label(frame, text=f"Catégorie : {tech.get('categorie')}").grid(row=2, column=0, sticky='w', pady=(4,0))
    tk.Label(frame, text=f"Reps : {tech.get('reps')}").grid(row=3, column=0, sticky='w', pady=(4,0))
    tk.Label(frame, text=f"Charge : {tech.get('charge')}").grid(row=4, column=0, sticky='w', pady=(4,0))
    tk.Label(frame, text=f"Repos : {tech.get('repos')}").grid(row=5, column=0, sticky='w', pady=(4,0))
    tk.Label(frame, text=f"Objectif : {tech.get('objectif')}").grid(row=6, column=0, sticky='w', pady=(4,0))
    tk.Label(frame, text="Notes :", font=("Helvetica", 10, "bold")).grid(row=7, column=0, sticky='w', pady=(8,0))
    notes_text = tk.Text(frame, height=6, width=60)
    notes_text.grid(row=8, column=0, pady=(4,0))
    notes_text.insert("1.0", tech.get("notes", ""))
    notes_text.config(state='disabled')
    btn_frame = tk.Frame(dlg)
    btn_frame.pack(pady=8)
    ttk.Button(btn_frame, text="Fermer", command=dlg.destroy).pack(side='left', padx=6)

def _sauvegarder_entrainement(app):
    if not getattr(app, "current_user", None):
        messagebox.showerror("Erreur", "Sélectionne un élève d'abord")
        return
    try:
        date = app.calendar.get_date()
        groupes = [g for g, v in app.groupes_vars.items() if v.get()]
        groupes_str = ", ".join(groupes) if groupes else "Aucun"
        program = app.program_selected_var.get() if hasattr(app, 'program_selected_var') else (app.program_listbox.get(0) if app.program_listbox.size() > 0 else "Standard")
        types = []
        if app.myofib_var.get():
            types.append("Myofib: " + app.myofib_var.get())
        if app.sarco_var.get():
            types.append("Sarco: " + app.sarco_var.get())
        types_str = " | ".join(types) if types else ""
        note = app.note_text.get("1.0", tk.END).strip()
        user_dir = _ensure_user_dir(app)
        fichier = os.path.join(user_dir, "entrainement.csv")
        # ensure header if file not exists
        if not os.path.exists(fichier):
            with open(fichier, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(["Date", "Groupes", "Programme", "Types", "Note"])
        with open(fichier, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow([date, groupes_str, program, types_str, note])
        messagebox.showinfo("Succès", "Entraînement sauvegardé.")
    except Exception as e:
        messagebox.showerror("Erreur", str(e))

